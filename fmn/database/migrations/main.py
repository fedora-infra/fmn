# SPDX-FileCopyrightText: Contributors to the Fedora Project
#
# SPDX-License-Identifier: MIT

import logging
from functools import cached_property
from pathlib import Path

import alembic.command
import alembic.config
import alembic.migration
import alembic.runtime.environment
import alembic.script

from ...core.config import get_settings

log = logging.getLogger(__name__)

HERE = Path(__file__).parent


class AlembicMigration:
    """Glue FMN (mainly its settings) and Alembic DB migrations together."""

    @cached_property
    def config(self):
        config = alembic.config.Config()
        config.set_main_option("script_location", str(HERE.absolute()).replace("%", "%%"))
        config.set_main_option(
            "sqlalchemy.url", get_settings().database.sqlalchemy.url.replace("%", "%%")
        )
        return config

    def create(self, comment: str, autogenerate: bool):
        alembic.command.revision(config=self.config, message=comment, autogenerate=autogenerate)

        if autogenerate:
            log.warning(
                ">>> Remember to edit the autogenerated migration script! Unedited, it would drop"
                " any support table not registered with your SQLAlchemy metadata."
            )

    def _get_current(self) -> set[str]:
        script = alembic.script.ScriptDirectory.from_config(self.config)

        current_revs = set()

        def _get_rev_current(rev, context):
            current_revs.update(
                _rev.cmd_format(verbose=False) for _rev in script.get_all_current(rev)
            )
            return []

        with alembic.runtime.environment.EnvironmentContext(
            self.config, script, fn=_get_rev_current, dont_mutate=True
        ):
            script.run_env()

        return current_revs

    def db_version(self):
        print("\n".join(self._get_current()))

    def upgrade(self, version: str):
        pre_revs = self._get_current()
        alembic.command.upgrade(self.config, version)
        post_revs = self._get_current()
        if pre_revs == post_revs:
            print("Nothing to upgrade.")
        else:
            print("Upgraded to:", ", ".join(post_revs))

    def downgrade(self, version: str):
        pre_revs = self._get_current()
        alembic.command.downgrade(self.config, version)
        post_revs = self._get_current()
        if pre_revs == post_revs:
            print("Nothing to downgrade.")
        else:
            print("Downgraded to:", ", ".join(post_revs) if post_revs else "<base>")

    async def needs_upgrade(self, async_connection):
        script = alembic.script.ScriptDirectory.from_config(self.config)
        latest = script.get_current_head()
        context = alembic.migration.MigrationContext.configure(
            url=self.config.get_main_option("sqlalchemy.url")
        )
        # In sync mode we could do: current = context.get_current_revision()
        result = await async_connection.execute(context._version.select())
        current_versions = [row[0] for row in result]
        if len(current_versions) != 1:
            # Database is not setup
            return True
        current = current_versions[0]
        if current != latest:
            return True
        else:
            return False


alembic_migration = AlembicMigration()
